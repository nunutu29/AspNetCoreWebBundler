using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace AspNetCoreWebBundler
{
    internal class BundleProcessor : BundleUglifier
    {
        private static readonly Regex RegexCssUrl = new Regex(@"url\s*\(\s*([""']?)([^:<)]+)\1\s*\)", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly string[] SupportedExt = { ".JS", ".CSS", ".HTML", ".HTM" };

        public event EventHandler<BundleProcessorEventArgs> Processing;
        public event EventHandler<BundleProcessorEventArgs> BeforeBundling;
        public event EventHandler<BundleProcessorEventArgs> AfterBundling;
        public event EventHandler<BundleProcessorEventArgs> MinificationSkipped;

        public static bool IsSupported(string file)
        {
            var fileExt = Path.GetExtension(file).ToUpperInvariant();
            return SupportedExt.Contains(fileExt);
        }

        public bool Process(string configFile)
        {
            return ProcessByCondition(configFile, bundle => true);
        }

        public bool ProcessBySourceFile(string configFile, string sourceFile)
        {
            return ProcessByCondition(configFile, bundle =>
            {
                foreach (var file in bundle.AbsoluteInputFiles)
                {
                    if (file.Equals(sourceFile, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }

                return false;
            });
        }

        private bool ProcessByCondition(string configFile, Func<Bundle, bool> shouldProcess)
        {
            var result = false;

            if (BundleConfig.TryParse(configFile, out var bundles))
            {
                var bundleFileFolder = new FileInfo(configFile).DirectoryName;

                // don't exand bndles immediatly, but one by one after processing,
                // so we can find autogenerated files

                foreach (var bundle in bundles)
                {
                    foreach (var inner in bundle.Expand())
                    {
                        if (shouldProcess(inner))
                        {
                            result |= ProcessBundle(bundleFileFolder, inner);
                        }
                    }
                }
            }

            return result;
        }

        private bool ProcessBundle(string baseFolder, Bundle bundle)
        {
            OnProcessing(bundle, baseFolder);

            // Flags to determine if the bundle or its minified version has changed
            var bundleChanged = false;
            var minChanged = false;

            // Read file contents and update the most recent write time
            ProcessBundleContent(bundle);

            // Get the minified file name for the output file
            var minFile = FileHelper.GetMinFileName(bundle.AbsoluteOutputFile);

            // Check if the output file needs processing based on the number of input files and naming
            if (minFile != bundle.AbsoluteOutputFile && (bundle.AbsoluteInputFiles.Count > 1 || bundle.Src[0] != bundle.Dest))
            {
                // Check if the content of the output file has changed
                var containsChanges = FileHelper.HasContentChanged(bundle.AbsoluteOutputFile, bundle.Content);

                // If changes are detected, handle the bundling process
                if (containsChanges)
                {
                    OnBeforeBundling(bundle, baseFolder, true);

                    // Ensure the parent directory for the output file exists and write the new content
                    FileHelper.CreateParentDirectory(bundle.AbsoluteOutputFile);
                    FileHelper.Write(bundle.AbsoluteOutputFile, bundle.Content);

                    OnAfterBundling(bundle, baseFolder, true);

                    bundleChanged = true;
                }
            }
            
            BundleUglifierResult minResult = null;

            // Check if minification is enabled for the bundle
            if (bundle.IsMinifyEnabled)
            {
                var outputWriteTime = File.GetLastWriteTimeUtc(minFile);
                var minifyChanged = bundle.MostRecentWrite >= outputWriteTime;

                // If the content has been modified since the last minification, perform minification
                if (minifyChanged)
                {
                    minResult = MinifyBundle(bundle);

                    // Update the write time if no changes were made during minification but the file exists
                    if (!minResult.Changed && File.Exists(minFile))
                    {
                        File.SetLastWriteTimeUtc(minFile, DateTime.UtcNow);
                    }

                    minChanged |= minResult.Changed;
                    minChanged |= minResult.SourceMapChanged;
                }
                else
                {
                    OnMinificationSkipped(bundle, baseFolder, false);
                }
            }

            // Check if GZip compression is enabled for the bundle
            if (bundle.IsGZipEnabled)
            {
                if (bundle.IsMinifyEnabled)
                {
                    if (minResult == null)
                    {
                        // If minResult is null but the minified file exists, GZip the file directly
                        if (File.Exists(minFile))
                        {
                            GZipFile(minFile, bundle, false, File.ReadAllText(minFile));
                        }
                    }
                    else
                    {
                        // GZip the minified content if minification resulted in changes
                        GZipFile(minFile, bundle, minResult.Changed, minResult.MinifiedContent);
                    }
                }
                else
                {
                    // GZip the original output file content if minification is not enabled
                    GZipFile(bundle.AbsoluteOutputFile, bundle, bundleChanged, bundle.Content);
                }
            }

            // Return true if either the bundle or the minified content has changed
            return bundleChanged || minChanged;
        }

        private static void ProcessBundleContent(Bundle bundle)
        {
            var mostRecentWrite = default(DateTime);
            var sb = new StringBuilder();

            foreach (var file in bundle.AbsoluteInputFiles)
            {
                if (File.Exists(file))
                {
                    string content;

                    if (file.EndsWith(".css", StringComparison.OrdinalIgnoreCase) && MustAdjustCssRelativePaths(bundle))
                    {
                        content = AdjustCssRelativePaths(file, bundle.AbsoluteOutputFile);
                    }
                    else
                    {
                        content = File.ReadAllText(file);
                    }

                    var lastWriteFile = File.GetLastWriteTimeUtc(file);

                    if (mostRecentWrite < lastWriteFile)
                    {
                        mostRecentWrite = lastWriteFile;
                    }

                    // adding new line only if there are more than 1 files
                    // otherwise we are preserving file integrity
                    if (sb.Length > 0)
                    {
                        sb.AppendLine();
                    }

                    sb.Append(content);
                }
            }

            bundle.MostRecentWrite = mostRecentWrite;
            bundle.Content = sb.ToString();
        }

        private static string AdjustCssRelativePaths(string absoluteInputFile, string absoluteOutputPath)
        {
            var cssFileContents = File.ReadAllText(absoluteInputFile);

            // apply the RegEx to the file (to change relative paths)
            var matches = RegexCssUrl.Matches(cssFileContents);

            // Ignore the file if no match
            if (matches.Count > 0)
            {
                var cssDirectoryPath = Path.GetDirectoryName(absoluteInputFile)!;

                foreach (Match match in matches)
                {
                    var quoteDelimiter = match.Groups[1].Value; //url('') vs url("")
                    var relativePathToCss = match.Groups[2].Value;

                    // Ignore root relative references
                    if (relativePathToCss.StartsWith("/", StringComparison.Ordinal))
                        continue;

                    //prevent query string from causing error
                    var pathAndQuery = relativePathToCss.Split(new[] { '?' }, 2, StringSplitOptions.RemoveEmptyEntries);
                    var pathOnly = pathAndQuery[0];
                    var queryOnly = pathAndQuery.Length == 2 ? pathAndQuery[1] : string.Empty;

                    var absolutePath = Path.GetFullPath(Path.Combine(cssDirectoryPath, pathOnly));
                    var serverRelativeUrl = PathHelper.MakeRelative(absoluteOutputPath, absolutePath);

                    if (!string.IsNullOrEmpty(queryOnly))
                        serverRelativeUrl += "?" + queryOnly;

                    var replace = string.Format("url({0}{1}{0})", quoteDelimiter, serverRelativeUrl);

                    cssFileContents = cssFileContents.Replace(match.Groups[0].Value, replace);
                }
            }

            return cssFileContents;
        }

        private static bool MustAdjustCssRelativePaths(Bundle bundle)
        {
            if (bundle.Minify.TryGetValue("adjustRelativePaths", out var value))
            {
                return (bool)value;
            }

            return true;
        }

        protected void OnProcessing(Bundle bundle, string baseFolder)
        {
            Processing?.Invoke(this, new BundleProcessorEventArgs(bundle, baseFolder, false));
        }

        protected void OnBeforeBundling(Bundle bundle, string baseFolder, bool containsChanges)
        {
            BeforeBundling?.Invoke(this, new BundleProcessorEventArgs(bundle, baseFolder, containsChanges));
        }

        protected void OnAfterBundling(Bundle bundle, string baseFolder, bool containsChanges)
        {
            AfterBundling?.Invoke(this, new BundleProcessorEventArgs(bundle, baseFolder, containsChanges));
        }

        protected void OnMinificationSkipped(Bundle bundle, string baseFolder, bool containsChanges)
        {
            MinificationSkipped?.Invoke(this, new BundleProcessorEventArgs(bundle, baseFolder, containsChanges));
        }
    }
}
